# Architecture Overview

## System Boundaries

The wallet service is a single Go binary that serves an HTTP API. Its only external dependency is PostgreSQL.

```
Client (HTTP) ──▶ wallet-service ──▶ PostgreSQL
```

There are no message queues, caches, external auth providers, or other services in the current architecture.

## Internal Structure

The application follows a layered architecture. Each layer depends only on the layer below it.

```
Router (chi)
  │ route matching, middleware mounting
  ▼
Middleware
  │ JWT extraction, user/wallet lookup, context injection
  ▼
Handler
  │ HTTP concerns: parse request, validate input, write response
  ▼
Service
  │ business logic: transaction orchestration, balance checks
  ▼
Repository
  │ sqlc-generated query execution, transaction management
  ▼
PostgreSQL (pgxpool)
```

### Package Responsibilities

| Package | What it does | What it does NOT do |
|---|---|---|
| `config/` | Loads `.env` and env vars via koanf, validates with `go-playground/validator` | Does not provide defaults beyond what koanf does |
| `database/` | Creates `pgxpool.Pool`, pings on startup | Does not run migrations or manage schema |
| `handler/` | Deserializes HTTP input, calls service, serializes HTTP output | Contains no business logic |
| `service/` | Orchestrates repository calls within transactions, enforces business rules (e.g. insufficient balance) | Does not touch HTTP types |
| `repository/` | Executes SQL (generated by sqlc), provides `WithTransaction` wrapper | Contains no business logic |
| `middleware/` | Parses `Authorization: Bearer` header, validates JWT, resolves user+wallet from DB, injects into context | Does not handle any route logic |
| `validations/` | Validates request bodies using `go-playground/validator` struct tags | Does not have access to the database |
| `router/` | Mounts `chi` routes, applies auth middleware to `/api/wallet/*` | Contains no handlers |
| `models/` | Defines request/response structs and error types | Contains no logic beyond `Error()` methods |

## Data Flow: TopUp Example

```
1. POST /api/wallet/topup {txn_id, amount}
2. Auth middleware: extract JWT → query user → query wallet → inject ctx
3. Handler: decode JSON body → validate (txn_id required, amount > 0)
4. Service.TopUp():
   a. Check if txn_id already exists → if yes, return current balance (idempotent)
   b. Begin DB transaction
   c. SELECT ... FOR UPDATE on wallet row (acquire lock)
   d. INSERT into transactions
   e. INSERT into ledgers (+amount for user wallet)
   f. INSERT into ledgers (-amount for system wallet)
   g. SELECT SUM(amount) for user wallet → new balance
   h. COMMIT
5. Handler: write 201 with balance
```

Steps 4b–4h all happen within a single PostgreSQL transaction. Any failure at any step causes a full rollback.

## Key Design Decisions

Detailed rationale in `docs/decisions/`:

- **Double-entry ledger**: balance is never stored, always computed as `SUM(amount)`. See [ADR-002](../decisions/002-double-entry-ledger.md).
- **Row-level locking**: `SELECT ... FOR UPDATE` serializes concurrent access per wallet. See [ADR-003](../decisions/003-concurrency-strategy.md).
- **Idempotency**: client-supplied `txn_id` prevents duplicate processing on retry.
- **No ORM**: sqlc generates type-safe Go from raw SQL. See [ADR-001](../decisions/001-technology-choices.md).
